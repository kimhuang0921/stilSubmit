##
# Setup File Template.
# Generated by ATEGen (Version 1.15.1 [linux x86_64_RHEL7] 31-Jan-2025).
# (c) Copyright 1998-2025 Test Insight Ltd.
##

##############################
# Input File Definition
# Notes:
# - STIL, WGL, SVF, TDL91 and AIF file types are supported
# - file type is determined automatically by content (except AIF)
# - force file type by setting input_file_type value below (automatic recognition is disabled)
##
input_file_type = ''     # valid values: STIL WGL TDL SVF AIF (optional if not AIF)

##############################
# Keep intermediate STIL files (Optional)
keep_stil_files = 0

################################
# 93000 AIF Reader Configuration
######

# Specifies AIC file (Mandatory)
aic_file = ''

# Specifies DVC file (Mandatory)
dvc_file = ''

# Specifies 93000 Pin Configuration file (Optional, may be defined in AIC)
pins_file = ''

# Specifies default AVC files directory (Optional, may be defined in AIC)
avc_dir = ''

# Ignore xfact specified in AIC (Optional, default = 0)
aic_ignore_xfact = 0

##############################
# WGL Reader Configuration
######

# Scan input padding value. (Optional)
# Valid values are: [01XZ]
wgl_scan_in_padding = '0'

# Scan output padding value. (Optional)
# Valid values are: [01XZ]
wgl_scan_out_padding = 'X'

# If true, scanchain inverters are ignored while processing scan data. (Optional)
# Valid values are: [01] (false,true)
wgl_skip_inverters = 0


# Purge unused timeplates. (Optional)
# Valid values are: [01] (false,true)
# Remove any unused timeplates from the output file, if true.
wgl_purge_unused_timeplates = 1

# Purge unused waveforms. (Optional)
# Valid values are: [01] (false,true)
# Remove any unused waveforms from the output file, if true.
# Note that unused timeplates will be removed too.
wgl_purge_unused_waveforms = 0

# Export WGL scanchains into STIL ScanStructures. (Optional)
# Valid values are: [01] (false,true)
wgl_export_scanchains = 0

# Add Drive-Off event. (Optional)
# Turn driver off in compare waveforms, if missing
# Valid values are: [01] (false,true)
wgl_add_drive_off = 1

# Allow undefined cell data. (Optional)
# If enabled, undefined cells will be set 
# to default values according to scan direction in/out: N/X
# Valid values are: [01] (false,true)
wgl_allow_undef_cell_data = 0

##############################
# TDL Reader Configuration
######

# Enable/disable scan structures import. (Optional, default = 1)
tdl_import_scan_structures = 1

# If enabled, generate CLOCK signal as 2-edge (RH/RL) instead of 3-edge (SBH/SBL),
# eliminating the first edge. (Optional, default = 0)
tdl_2_edge_clocks = 0

# If enabled, handle async clocks as pattern clocks. (Optional, default = 0)
tdl_async_clocks_as_pattern_clocks = 0

# Purge unused timing data. (Optional)
# Valid values are: [01] (false,true)
# Remove any 'unused' timing timplates/waveforms from the output file, if true.
tdl_purge_unused_timing = 0

# Drive off position. (Optional, default = 0ns)
# Valid values are: absolute times, e.g. '5ns', '2000ps' or reserved keyword 'as_drive_on'
tdl_drive_off_position = ''

# Signal drive off position. (Optional)
# Pin to position map
# Position valid values are: absolute times, e.g. '5ns', '2000ps' or reserved keyword 'as_drive_on'
# tdl_signal_drive_off_position = { 'data' : '2ns'}

##############################
# SVF Reader Configuration
######

# Custom TAP Signals Names
svf_tck  = 'tck' # TCK name
svf_tdi  = 'tdi' # TDI name
svf_tms  = 'tms' # TMS name
svf_trst = 'trst' # TRST name
svf_tdo  = 'tdo' # TDO name

# Timing
svf_tck_freq    = 10000000 # TCK frequency [Hz]
svf_sck_freq    = 10000000 # SCK frequency [Hz]
svf_tset_prefix = 'T' # Default timeset base name

# Timing Edges (defined as timeset period factor)
# clock:
svf_tck_d0 = 0 # drive complement
svf_tck_d1 = 0.25 # drive data [pulse]
svf_tck_d2 = 0.75 # drive complement
# inputs:
svf_in_d1  = 0 # drive data
# outputs:
svf_out_r0 = -1 # driver off
svf_out_r1 = 0.24 # strobe data

# Comments Processing
svf_enable_ds_comments     = 1 # "//" comments enabled
svf_enable_em_comments     = 1 # "!"  comments enabled
svf_generate_tap_comments  = 1 # generate TAP comments
svf_generate_scan_comments = 0 # generate SDI/SDO data comments

# Misc
svf_pio_stop_tck = 0 # stop TCK when PIO command is executed

##############################
# ATE Generator Configuration
######

# Target Platform.(Mandatory)
# Valid values depend on configuration file installed.
# Currently available targets:
#  "93000DD"
#  "93000SMT8"
#  "TeradyneJ750"
#  "TeradyneUltraFlex"
#  "TeradyneUltraFlexPlus"
target = '93000SMT8'

# Unify WFT periods
# Modify all WFTs to use identical period
#  - scan all WFTs, find GCD of all periods (base period)
#  - split WFTs to use only base period
# Possible values: 0 (disable option) and 1 (enable option), default is 0
unify_periods = 0

# Cycle boundary edge placement (only applicable when unify_periods is enabled)
# Valid values:
# 'next_vector' - insert edge at position 0 of the next vector (default)
# 'curr_vector' - append edge to to the current vector
#unify_periods_boundary_edge_placement = 'next_vector'

# Cycle boundary edge placement for specific signals (only applicable when unify_periods is enabled).
#unify_periods_signal_boundary_edge_placement = { 'Sig1' : 'curr_vector', ... }

# Additional pattern comment.
# This comment will be added to the first vector of all patterns.
pattern_comment = ''

# Overwrite timing file.(Optional)
# File containing STIL with timing definitions overriding those from input file(s).
overwrite_timing = ''

# STIL PatternExec name. (Optional)
# First one is used if not specified.
stil_pattern_exec = ''

# Pattern naming convention flag ( Optional, default = 1 ).
# If stil_file_name_as_pattern_name = 0, use STIL Pattern name when generating pattern.
# If stil_file_name_as_pattern_name = 1, use STIL File name.
stil_file_name_as_pattern_name = 1

# Project naming convention flag ( Optional, default = 0 ).
# If stil_file_name_as_project_name = 0, use project_name parameter as a base name for signal, timing, levels etc. files.
# If stil_file_name_as_project_name = 1, use STIL File name.
stil_file_name_as_project_name = 0

# Use STIL file name as WFT prefix ( Optional, default = 0 ).
stil_file_name_as_wft_prefix = 0

# Label suffix flag ( Optional, default =  ).
# Add custom suffix to all pattern and burst names
label_suffix = ""

# Set ScanIn signals padding value ( Optional, default = '0' ).
# Only works if no padding value is specified for a scan pin prior to Shift block.
stil_pad_scanin = '0'

# Set ScanOut signals padding value ( Optional, default = 'X' ).
# Only works if no padding value is specified for a scan pin prior to Shift block.
stil_pad_scanout = 'X'

# Scan data padding in ShiftIncremental block ( Optional, default = 0 ).
# If shift_increment_disable_padding = 0, data padding will be done according to Shift processing rules .
# If shift_increment_disable_padding = 1, data padding will not be permitted ( fail with error ).
shift_increment_disable_padding = 0

# Scan data handling in a multiple-vector Shift block ( Optional, default = 0 ).
# If stil_shift_data_increment = 0, data will be shifted once per block.
# If stil_shift_data_increment = 1, data will be shifted on every # argument.
stil_shift_data_increment = 0

# Alternative WFC Map. (Optional)
# Define alternative WFC Map for data assignment conflict resolution.
# This map will only be used if native STIL WFCMap fails to resolve a conflict.
# Example: { '0X' : '0', '1X' : '1', ...   }
stil_wfc_map = {
    }

# Global STIL Action Map. (Optional)
# Allows users to globally remap STIL action states in Timing section.
# Example: { 'Z': 'X', 'P': D' }
stil_action_map = { }

# Exit with an error if signal is assigned the value twice in the same vector
# and WFCMap is either absent or does not resolve the ambiguity. (Optional, default is 0).
error_on_2_state_ambiguity = 0

# Force edge strobe ( Optional, default = 0 ).
# If set to 1, STIL window compare events will be replaced with edge compare.
# If set to 0, STIL window compare events will be kept.
force_edge_strobe = 0

# Generate complementary waveforms ( Optional, default = 0 ).
# If set to 1, additional waveforms with "complementary" actions will be generated:
# - for each single-drive   waveform - new ForceUp/Down waveforms
# - for each single-compare waveform - new CompareHigh/Low/Off/Unknown waveforms.
generate_complementary_waveforms = 0

# STIL resource tags handling configuration ( Optional, default = 0 ).
# If ignore_stil_rtags = 0, STIL <rtag> data will be stored and possibly used ( target dependent ).
# If ignore_stil_rtags = 1, STIL <rtag> data will be ignored.
ignore_stil_rtags = 0

# STIL ScanStructures handling configuration ( Optional, default = 1 ).
# If ignore_scan_structures = 0, STIL ScanStructures data will be stored and possibly used ( target dependent ).
# If ignore_scan_structures = 1, STIL ScanStructures data will be ignored.
ignore_scan_structures = 1

# STIL Pseudo Signals handling configuration ( Optional, default = 1 ).
# If stil_ignore_pseudo_signals = 0, Signals of type Pseudo will be processed similar to other signals.
# If stil_ignore_pseudo_signals = 1, Signals of type Pseudo will be ignored.
stil_ignore_pseudo_signals = 1

# Support STARC-compiant STIL ( Optional, default = 0 ).
# If stil_starc = 0, STARC features are not supported.
# If stil_starc = 1, the below STARC features are supported:
# - IddqTestPoints statement can have Detection attribute
# - Pattern name can be identical to PatternBurst name
#   (but nested bursts are not allowed)
stil_starc = 0

# Handling of STIL Fixed opcode ( Optional, default = 1 ).
# If fixed_as_breakpoint = 0, Fixed opcode in STIL Patterns will not be treated as Breakpoint.
# If fixed_as_breakpoint = 1, Fixed opcode in STIL Patterns will be treated as Breakpoint.
fixed_as_breakpoint = 1

# Allow override of STIL Fixed value in subsequent vectors ( Optional, default = 1 ).
# If fixed_allow_override = 0, Fixed value will be kept and warning issued.
# If fixed_allow_override = 1, Fixed value will be silently replaced by vector value.
fixed_allow_override = 1


# Output directory. (Optional, default = 'output')
workdir = 'output'

# Project name. (Optional, default = 'project' )
# Serves as a base name for all named TP blocks
project_name = ''

# Ignore free-running clock signals in patterns ( Optional, default = 0 ).
ignore_free_running_clocks_in_patterns = 0

# Pattern signals definition. (Optional)
# Signals, signal groups and lists of signals allowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Define a reduced set signals to be used in the pattern only.
# Signals not in the list will still appear in 'workspace' portion
# of the test program.
# Example: [ 'sig1', 'sig2', 'sigN' ]
pattern_signals = [  ]

# Define global signals set. (Optional)
# Both signals and signal groups alowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Only specified signals will be passed to the target test program.
# This parameter is mutually exclusive with 'exclude_signals'.
# Example: [ 'sig1', 'sig2', 'sigN' ]
include_signals = [  ]

# Define set of signals to exclude from target test program. (Optional)
# Both signals and signal groups alowed.
# Wildcards allowed ( only '?' and '*' supported ).
# Specified signals will be completely removed from the target test program.
# This parameter is mutually exclusive with 'include_signals'.
# Example: [ 'sig1', 'sig2', 'sigN' ]
exclude_signals = [  ]

# Rename signals. (Optional)
# Define a mapping between simulation signals and target ATE pins.
# Any signals not specified in the map will use original names.
# Signal groups are not allowed.
# Note: this will not affect any signal-related configuration settings above,
#       i.e. all signal-related setup variables should always refer to the original signal names.
# Example: { 'signal_name1' : 'ATE_signal_name1', 'signal_name2' : 'ATE_signal_name2', ...   }
rename_signals = {
    }


# Stop on uninitialized signals ( Optional, default = 0 ).
stop_on_uninitialized_signals = 0

# Allow new signals assignments to appear mid pattern in STIL ( Optional, default = 1 ).
# For example, if allow_new_signals_mid_pattern is set to 0, the following case will cause an error:
# Pattern P0 {
#   WFT T0;
#   V { sig1 = 0; }
#   V { sig1 = 0; sig2 = 0; }
allow_new_signals_mid_pattern = 1

# Rename WFTs. (Optional)
# Define a mapping between simulation WFTs and target ATE WFTs.
# Example: { 'WFT1' : 'ATE_WFT1', 'WFT2' : 'ATE_WFT2', ...   }
rename_wfts = {
    }

# Timing Map. (Optional)
# Define STIL timing mapping in order to fit to tester restrictions.
# For example, map all dual compare waveforms to single compare.
# By default all inputs with undefined value are mapped to 0.
# The following wildcards can be used:
#     I for input  events - D, U, P, A, B
#     O for output events - H, L, X, x, T, V, l, h, t, v
#     . for any event.
# Example: { 'N' : 'D' }
timing_map = {
    'N': 'D',
    }

# Signal Timing Map. (Optional)
# Define STIL timing mapping for specific signals.
# By default global timing map is used.
# Wildcards can be used (same as in Timing Map).
# Example: { 'STIL_signal_name1' : { 'UDU' : '-DU' , 'DUD' : '-UD' , ... } , ... }
signal_timing_map = {
    }

# Sequence Map. (Optional)
# Define pattern states mapping for specific signals.
# Valid values are 0/1/Z/L/H/T/X.
# Example: { 'signal_name1' : { '010' : '111' , 'LHL' : 'LXL' , ... } , ... }
sequence_map = {
    }

# Equation Based Timing. (Optional, default = 1)
# Generate equation (Spec) based timing if original timing only used absolute values without any Spec definition.
# For example, equation specified as 10ns (when period is 100ns)
# will become 0.1*per_100, where per_100 is a new Spec variable.
equation_based_timing = 1

# Frequency Based Timing. (Optional, default = 0)
# Relevant only if Equation Based Timing is on.
# If set to 0, timing equations will be based on period.
# If set to 1, timing equations will be based on frequency.
frequency_based_timing = 0

# Parametrized Equations. (Optional, default = 0)
# Relevant only if Equation Based Timing is on.
# If set to 0, timing equations will be based on percentage period ratio.
# If set to 1, timing equations will be based on spec period ratio.
# For example, equation specified as 10ns (when period is 100ns)
# will become t1_ratio1*per_100, where t1_ratio1 is a new Spec variable.
parametrized_equations = 0

# Optimize Spec Variables in Equation Based Timing Mode. (Optional, default = 1)
# If optimize_equation_based_timing_vars = 1, a spec variable for each unique WFT period will be generated (e.g. per_100).
# If optimize_equation_based_timing_vars = 0, a spec variable for each WFT will be generated (e.g. per_SHIFT, per_CAPTURE).
optimize_equation_based_timing_vars = 1

# Vector Comment Source. ( Optional, default = ['Annotation'] )
# Vector comment is placed before the vector call in the vector comment field, as follows:
# 'Annotation' use the content of the annotation block ( Ann {* .. *} )
# 'C' use the content of the C comment ( /* .. */ )
# 'C++' use the content of the C++ comment ( // ... )
# 'Macro' Places name of Macro called in the vector comment field
# 'Procedure' Places name of Procedure called in the vector comment field.
# 'Scan Instance' Places the scan instance in the vector comment field (i.e. the number of times the Shift
#                 statement has been called in the context of a Pattern block)
# 'Label' Places STIL Label name in the vector comment field
# 'Embedded' Used for Annotation/C/C++ comment appearing inside Vector statement (only if separate_vector_comments = 1)
#  Note: more the one comment type may be defined, as follows: [ 'C', 'C++', 'Macro' ]
vector_comment_source = [ 'C++', 'C', 'Annotation' ]

# Same line comment handling. ( Optional, default = 0 )
# If set to 1, attach comment to the vector at the same line.
# If set to 0, attach it to the next vector
same_line_comment = 0

# Handling of comment inside Vector statement. ( Optional, default = 0 )
# If set to 1, assign comment type 'Embedded'.
# If set to 0, assign comment type as usual, according to comment format.
separate_vector_comments = 0

# Define set of scan cells to mask. (Optional)
# Example: [ 'cell1', 'cell2', 'cellN' ]
mask_scan_cells = [  ]

# Define set of scan chains to mask. (Optional)
# Example: [ 'chain1', 'chain2', 'chainN' ]
mask_scan_chains = [  ]

# Define set of scan signals to mask. (Optional)
# Example: [ 'sig1', 'sig2', 'sigN' ]
mask_scan_signals = [  ]

# Scan pattern start label. (Optional, default = '')
# Generation of scan pattern will start from this label.
# If empty, generation starts at the start of the pattern.
scan_pattern_start = ''

# Scan pattern stop label. (Optional, default = '')
# Generation of scan pattern will stop at this label.
# If empty, generation stops at the end of the pattern.
scan_pattern_stop = ''

# Generate pattern from specified cycle value (Optional, default = 1 ).
cycle_start = 1

# Generate pattern until specified cycle value (Optional, default = -1 <end of pattern>).
cycle_end = -1

# Skip non-indexed multibit events. (Optional, default = 1)
# In multibit waveforms, use only indexed events when creating wfc sequence.
# For example, waveform "eE {'0ns' D/U[0]; '2.5ns' Z; }"
# should be referred in pattern as e or E (if parameter is set to 1).
# or as ee or Ee (if parameter is set to 0).
skip_nonindexed_events = 1

# Define set of user keywords to be processed. (Optional)
# The following keywords can be specified:
# 'ShiftIncrement'   : similar to Shift, but if contains multiple vectors, data is shifted after each vector
# 'InfiniteLoop'     : handled as non-looped sequence of vectors
# 'FreeRunning'      : defines async free-running clock
# 'ScanClock'        : defines scan clock
# 'DifferentialInvOf': name of the positive diff. pin
# 'BitAlignment'     : 1149-10 bit alignment
# 'LatencyAlignment' : 1149-10 latency alignment
# 'MatchAttrs'       : match loop custom attrs
# Example: [ 'kwd1', 'kwd2' ]
process_user_keywords = [  ]

# Define custom set of user keywords. (Optional)
# This definition is equivalent to the native STIL UserKeywords statement
# Example: [ 'kwd1', 'kwd2' ]
user_keywords = [  ]

# Preprocess user comments using specified callback.
# The callback is expected to accept a single string as input and return a single string as output.
# For example, def my_callback( comment_from_pattern ): return comment_from_pattern + 'my extra info'
#adjust_comment = lambda x : x

# Generate pins ( Optional, default = 1 ).
# If set to 1, ATE pin definitions will be generated.
# If set to 0, ATE pin generation will be skipped ( target dependent ).
generate_pins = 1

# Generate timing ( Optional, default = 1 ).
# If set to 1, ATE timing definitions will be generated.
# If set to 0, ATE timing generation will be skipped ( target dependent ).
generate_timing = 1

# Generate levels ( Optional, default = 1 ).
# If set to 1, ATE DC levels definitions will be generated.
# If set to 0, ATE DC levels generation will be skipped ( target dependent ).
generate_levels = 1

# Generate patterns ( Optional, default = 1 ).
# If set to 1, ATE patterns will be generated.
# If set to 0, ATE patterns generation will be skipped ( target dependent ).
generate_patterns = 1

# Generate ( Optional, default = 1 ).
# If set to 1, ATE workspace will be generated.
# If set to 0, ATE workspace generation will be skipped ( target dependent ).
generate_workspace = 1

# STIL reader mode.(Optional)
# Valid values are: one_pass two_pass
stil_reader_mode = 'one_pass'

# Mask failures file
# If the parameter is not empty, mask failures in STIL pattern
#  - read vectors, mask failing signals/cycles according to informastion from failures file
#  - create masking waveforms for relevant signals
# Each line of failures file should contain
#   cycle number, signal name, expected data and actual data separated by tabs
##
#mask_failing_signals = 'path'

# Fix failures file
# If the parameter is not empty, fix failures in STIL pattern
#  - read vectors, fix failing signals/cycles according to informastion from failures file
#  - create fixing waveforms for relevant signals
# Each line of failures file should contain
#   cycle number, signal name, expected data and actual data separated by tabs
##
#fix_failing_signals = 'path'

# STIL Editor setup file.(Optional)
stil_editor_setup = ''

############################
# Virtual Signal Generation
#

# Define virtual signals ( optional ).
#  Attributes:
#   name:	 virtual signal name ( mandatory, must be unique )
#   type:	 virtual signal type ( optional, one of [ In | Out | InOut ] )
#   opcode:	 virtual signal operator ( mandatory )
#     'Fixed':            Fixed state signal ( arg1 = state [DUZLHXT], arg2 = time )
#     'Copy':             Copy reference signal ( arg1 = ref. signal name )
#     'Not':              Copy reference signal, inverting states ( arg1 = ref. signal name )
#   args:	 operator attributes ( depend on 'op' selected )
#
# virtual_signals = [ 
#   { 'name': 'sig_name', 'type': 'sig_type', 'opcode': 'opcode', 'args': [ 'arg1', 'arg2' ...] },
#   { 'name': 'sig_name', 'type': 'sig_type', 'opcode': 'opcode', 'args': [ 'arg1', 'arg2' ...] } ...
# ]

##################################
# 93000SMT8 flags 
######

# Controls output behavior depending on SmarTest version
smt8_smartest_version = "8.0.0"

# Tester model selection.
# 'PS1600','PS9G','PS5000','PSMLS' are valid models for 93000SMT8.
smt8_tester_model = "PS1600"

# Turns on waveform incremental mode when set to a file path.
# The combinations file allows generation of multiple STIL patterns,
# while keeping consistent timing, compatible with all generated binary patterns.
# This mode requires identical timing to be shared between all STIL patterns.
# It is most useful in case of X-Modes, when different STIL patterns have different combinations of STIL waveforms.
# Waveform incremental mode is compatible with multiport.
smt8_combinations_file = None

# Allow addition of new waveforms in combinations file.
smt8_combinations_allow_new_waveforms = 1

# Allow addition of new break waveforms in combinations file
# (to allow, both this flag and smt8_combinations_allow_new_waveforms must be set to 1).
smt8_combinations_allow_new_break_waveforms = 1

# Allow combinations file update.
# Setting to 0 will disable both smt8_combinations_allow_new_waveforms and
# smt8_combinations_allow_new_break_waveforms.
smt8_allow_combinations_file_update = 1

# Ignore differences in AC spec values between input file and combinations file.
smt8_combinations_ignore_spec_values = 0

# Allow remapping of single pattern actions to dual ones for functional (digInOut) pins.
# Currently limited to vforce, vmeas, iforce, imeas which are mapped to
# vforceImeas, iforceVmeas, iforceVmeas and vforceImeas respectively
smt8_single_to_dual_actions_remapping = 0

# Enable site memory sharing
smt8_site_memory_sharing = 0

# Compress identical vectors to single vector loops
smt8_repeat_compression = 0

# When repeat compression is on: compress identical vectors to single vector loops althogh they don't have the same comment.
# The different comments from the vectors will be placed before the created loop.
smt8_repeat_compression_ignore_comments = 1

# Data size for a single BCMT vector comment command
smt8_comment_max_size = 640000

# If specified, preprocess user comments using specified callback.
smt8_adjust_comments = None

# Loops will be flattened if loop count is less than repeat break value.
# Loops will be flattened by default if (loop_size * loop_count + 6)/7 < 1 + (loop_count + 6)/7
smt8_repeat_break = None

# Expand original loops in source STIL files
smt8_expand_loops = 0

# Value to use as loop count for infinite loop
smt8_infinite_loop_count_substitute = 1

# Use STIL History block as global pattern comment
smt8_use_stil_history_as_pattern_comment = 0

# Spec files layout:
# - default - generate top spec file which imports separate var declarations, groups, timing, wavetables, levels files.
# - flat    - generate a single spec file.
# - modular - like default layout, but with separate files for timing and levels variables.
smt8_spec_layout = "default"

# Keep unused AC and DC variables
smt8_keep_spec_variables = 1

# Add STIL information as comments to timing files
smt8_tim_comments = 0

# Add tool version and generation date as comments to all spec files
smt8_header_comments = 1

# Don't create signal group definitions if those groups are not used in timing and level declarations in STIL
smt8_skip_unused_signal_groups = 0

# Allow unify periods
smt8_allow_unify_periods = 0

# Add comment in order to identify vectors where allow_unify_periods was applied.
smt8_unify_periods_comments = 0

# Enable or disable group definitions in timing files
smt8_use_tim_groups = 0

# Enable or disable pin-based timing
smt8_pin_based_tim = 0

# Exclude pins from grouping in timing files
smt8_tim_group_exclude_pins = []

# When multiple values are specified for a DC resource, generate
# multiple levelsets in the level files.
smt8_multiple_levels_to_clev = 0

# Apply X-Mode factor to all patterns.
# The value of Xmode factor should be an integer or "auto"
# to apply maximum possible Xmode factor. Maximum possible Xmode
# factor is calculated based on actual timing and vector combinations.
smt8_xmode_factor = 1

# Align patterns execution time considering xmodes.
smt8_align_xmode_patterns = 0

# Apply BFLM alignment to patterns
smt8_bflm_mode = 0

# Repeat count for wait vectors in BFLM match loop
smt8_bflm_match_repeat_count = 0

# Enable or disable receive edge optimization
smt8_optimize_receive_edges = 1

# Enable or disable drive edge optimization
smt8_optimize_drive_edges = 1

# Allow use of CTIM.
smt8_allow_ctim = 0

# Allow use of CTIM immediate.
smt8_allow_ctim_immediate = 0

# Map from signal name to WFC using in CTIM padding vector for pure drive states.
# Default is using the same WFC as in the previous vector for drive state, and mask state for compare state.
# Example:
# smt8_ctim_immediate_padding = { 'sig1' : 'D', 'sig2' : 'Z' }
smt8_ctim_immediate_padding = {}

# Use STIL WFT names to generate timing set names.
smt8_ctim_wft_based_sets = 0

# Create separate timingsets by WFT name in case of CTIM.
smt8_optimize_timingsets = 0

# Force a timingset per WFT in case of CTIM.
smt8_force_ctim_immediate = 0

# Print cycle and vector numbers
smt8_cycle_numbering = 0

# Create all_inputs and all_outputs signal groups for debug purposes
smt8_auto_create_signal_groups = 0

# Use specific channel mapping from STIL Environment block
smt8_use_channel_mapping = None

# Import model file. Model file is used to assign or validate channel
# numbers for pin configuration generation
smt8_use_model_file = None

# Enable or disable creation of code that is not loadable
smt8_strict_mode = 0

# Exclude pins from grouping in level files
smt8_levels_group_exclude_pins = []

# Enable or disable scan diagnostics
smt8_generate_vmap = 0

# Generate HVM diagnostics based on shift outs
smt8_hvm_shift_out_patterns = 0

# Print vector usage summary for each binary pattern
smt8_vector_memory_summary = 0

# Allow match loops with number of vectors not aligned to x-mode
smt8_allow_nonaligned_match_loops = 0

# PS9G signals list
smt8_ps9g_signals = []

# Use high speed scan test mode
smt8_high_speed_scan_mode = 0

# minimum testpoints count value
smt8_testpoints = 8192

# Enable or disable printing full timing violations report
smt8_full_timing_violations_log = 0

# Generate report file for each pattern, containing mapping of ate cycles to source cycles.
smt8_generate_ate_cycle_mapping = 0

# Customize the first cycle number, used by generate_ate_cycle_mapping and cycle_numbering parameters.
smt8_cycle_numbering_start_cycle = 0

# Add signals renaming mapping to the global pattern comment.
smt8_annotate_rename_signals = 0

